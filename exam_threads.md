# Экзамен. Многопоточность.

## Оглавление

1. [Чем отличается процесс от потока?](#1-Чем-отличается-процесс-от-потока)
2. [Каким образом можно создать поток?](#2-Каким-образом-можно-создать-поток)
3. [Как работают методы sleep, yield, wait, notify и notifyAll?](#3-Как-работают-методы-sleep-yield-wait-notify-и-notifyAll)
4. [Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-Объясните-следующие-термины-монитор-мьютекс-критическая-секция)
5. [Как работает join()?](#5-Как-работает-join)
6. [Что такое DeadLock? Приведите примеры.](#6-Что-такое-DeadLock-Приведите-примеры)
7. [Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-Назовите-различия-между-Collections-synchronizedMap-new-HashMap-и-ConcurrentHashMap)
8. [Различия в интерфейсах Runnable и Callable.](#8-Различия-в-интерфейсах-Runnable-и-Callable)
9. [Различия между isInterrupted(), interrupted(), interrupt().](#9-Различия-между-isInterrupted-interrupted-interrupt())
10. [Что происходит при вызове Thread.interrupt()?](#10-Что-происходит-при-вызове-Thread.interrupt)
11. [Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.](#11-Перечислите-ВСЕ-причины-по-которым-может-быть-выброшено-InterruptedException)
12. [Назовите отличия synchronized{} и ReentrantLock.](#12-Назовите-отличия-synchronized-и-ReentrantLock)
13. [Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.](#13-Приведите-наиболее-существенное-отличие-между-CountDownLatch-и-CyclicBarrier)
14. [Приведите наиболее существенное отличие между CyclicBarrier и Phaser.](#14-Приведите-наиболее-существенное-отличие-между-CyclicBarrier-и-Phaser)
15. [Расскажите про Exchanger.](#15-Расскажите-про-Exchanger)
16. [Отличие Thread.start() и Thread.run()?](#16-Отличие-Thread-start-и-Thread-run-)
17. [Объясните ключевое слово volatile.](#17-Объясните-ключевое-слово-volatile)
18. [Расскажите про приоритеты потока.](#18-Расскажите-про-приоритеты-потока)
19. [Что такое потоки-демоны?](#19-Что-такое-потоки-демоны)
20. [Назовите все возможные состояния потока.](#20-Назовите-все-возможные-состояния-потока)
21. [Что такое race condition?](#21-Что-такое-race-condition)
22. [Что такое Thread Local переменная?](#22-Что-такое-Thread-Local-переменная)
23. [Что такое FutureTask?](#23-Что-такое-FutureTask)
24. [Что такое Thread Pool?](#24-Что-такое-Thread-Pool)
25. [Что такое Semaphore?](#25-Что-такое-Semaphore)
26. [Чем отличается submit от execute у ExecutorService?](#26-Чем-отличается-submit-от-execute-у-ExecutorService)
27. [Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#27-Чем-отличается-shutdown-от-shutdownNow-у-ThreadPoolExecutor)
28. [Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#28-Как-создать-ThreadPool-у-ExecutorService-только-на-1-на-5-на-неограниченное-количество-потоков)
29. [Что такое ReadWriteLock?](#29-Что-такое-ReadWriteLock)
30. [В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#30-В-чём-отличие-Thread-от-FutureTask-В-чём-отличие-Thread.interrupt-и-FutureTask-cancel)
31. [Расскажите про шаблон проектирования Producer Consumer.](#31-Расскажите-про-шаблон-проектирования-Producer-Consumer)
32. [Как можно запустить параллельный поток (parallelStream)?](#32-Как-можно-запустить-параллельный-поток-parallelStream)
33. [Что делают методы parallel и sequential?](#33-Что-делают-методы-parallel-и-sequential)
34. [Расскажите про порядок следования элементов в параллельном потоке и его особенностях.](#34-Расскажите-про-порядок-следования-элементов-в-параллельном-потоке-и-его-особенностях)
35. [В чем разница между методами forEach и forEachOrdered?](#35-В-чем-разница-между-методами-forEach-и-forEachOrdered)
36. [В чем разница между применением метода peek() в последовательном и параллельном потоках?](#36-В-чем-разница-между-применением-метода-peek-в-последовательном-и-параллельном-потоках)
37. [Что делает метод unordered?](#37-Что-делает-метод-unordered)
38. [Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?](#38-Когда-имеет-смысл-распараллеливать-поток-и-какие-при-этом-должны-соблюдаться-условия)
39. [Расскажите про Java NIO и её главные составляющие.](#39-Расскажите-про-Java-NIO-и-её-главные-составляющие)
40. [Что такое канал?](#40-Что-такое-канал)
41. [Что такое буфер?](#41-Что-такое-буфер)
42. [Что такое селектор?](#42-Что-такое-селектор)
43. [Когда есть смысл использовать Java NIO?](#43-Когда-есть-смысл-использовать-Java-NIO)
44. [Что такое PipedStreams? Как они устроены?](#44-Что-такое-PipedStreams-Как-они-устроены)

## 1 Чем отличается процесс от потока?

- Процесс - это задача, выполняемая процессором, поэтому количество возможных параллельных процессов равно количеству
  процессоров. Процесс может запускать потоки (или нити), то есть потоков может быть сколько угодно. Поток - это
  наименьшая единица выполнения внутри процесса. То есть идет некое разбиение процесса на подзадачи, которые выполняются
  потоками, переключающимися между собой.
- Каждый процесс имеет свой собственный адресное пространство и системные ресурсы. Потоки одного процесса разделяют его
  адресное пространство и ресурсы.
- Процессы не могут взаимодействовать между собой и обмениваться данными, а потоки могут.

Итого:

+ процессы обеспечивают параллелизм, так как каждый процесс выполняется на отдельном процессоре или ядре;
+ потоки обеспечивают многозадачность внутри одного процесса, позволяя выполнять несколько задач одновременно;

+ [К оглавлению &#8593;](#Оглавление)

## 2 Каким образом можно создать поток?

Чтобы создать поток, необходимо воспользоваться классом java.lang.Thread

```java
Thread thread=new Thread(
        ()->System.out.println(Thread.currentThread().getName())
        );
```

Конструктор этого класса принимает функциональный интерфейс java.lang.Runnable, который имеет один метод run(). Методы,
определенные в методе run(), будет выполняться в многозадачной среде.

Метод start() указывает виртуальной машине, что операторы, описанные в конструкторе, нужно запустить в отдельной нити.

Пример:

```java
public class ConcurrentOutput {
    public static void main(String[] args) {
        Thread thread = new Thread(
                () -> System.out.println(Thread.currentThread().getName())
        );
        thread.start();
        System.out.println(Thread.currentThread().getName());
    }
}
```

Если не вызывать метод start(), а вызвать напрямую метод run():

```java
public class ConcurrentOutput {
    public static void main(String[] args) {
        Thread another = new Thread(
                () -> System.out.println(Thread.currentThread().getName())
        );
        another.run();
        System.out.println(Thread.currentThread().getName());
    }
}
```

То получим в консоли

```
main
main
```

Это происходит потому, что метод run напрямую вызывает операторы в той же нити, в которой запущен этот метод. run() не
дает указания выполнить свои операторы в отдельной нити, как это делаем метод start().

[К оглавлению &#8593;](#Оглавление)

## 3 Как работают методы sleep, yield, wait, notify и notifyAll?

+ sleep - приостанавливает выполнение нити на указанное время и переводит нить в состояние TIMED_WAITING;
+ yield - этот метод принудительно передает свой квант времени другим нитям; Пример:

```java
while(door.isClosed){ // пока дверь закрыта
        Thread.yield();    // указать процессору перейти к другим потокам
        }
```

+ wait - переводит поток в режим ожидания WAITING;
+ notify - обратно переводит поток в режим выполнения;
+ notifyAll - будит все нити, которые ждали изменения состояния.

[К оглавлению &#8593;](#Оглавление)

## 4 Объясните следующие термины: монитор, мьютекс, критическая секция.

[К оглавлению &#8593;](#Оглавление)

## 5 Как работает join()?

Метод join() позволяет вызывающему потоку ждать поток, у которого этот метод вызывается. Например:

```java
public class ThreadStop {
    public static void main(String[] args) throws InterruptedException {
        Thread progress = new Thread(
                () -> {
                    while (!Thread.currentThread().isInterrupted()) {
                        try {
                            System.out.println("start ...");
                            Thread.sleep(10000);
                        } catch (InterruptedException e) {
                            System.out.println(Thread.currentThread().isInterrupted());
                            System.out.println(Thread.currentThread().getState());
                        }
                    }
                }
        );
        progress.start();
        Thread.sleep(1000);
        progress.interrupt();
        progress.join();
    }
}
```

В данном примере главный поток, который исполняет метод main, будет ждать окончания выполнения потока progress.

[К оглавлению &#8593;](#Оглавление)

## 6 Что такое DeadLock? Приведите примеры.

[К оглавлению &#8593;](#Оглавление)

## 7 Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

[К оглавлению &#8593;](#Оглавление)

## 8 Различия в интерфейсах Runnable и Callable.

[К оглавлению &#8593;](#Оглавление)

## 9 Различия между isInterrupted(), interrupted(), interrupt().

[К оглавлению &#8593;](#Оглавление)

## 10 Что происходит при вызове Thread.interrupt()?

[К оглавлению &#8593;](#Оглавление)

## 11 Перечислите ВСЕ причины по которым может быть выброшено InterruptedException.

[К оглавлению &#8593;](#Оглавление)

## 12 Назовите отличия synchronized{} и ReentrantLock.

[К оглавлению &#8593;](#Оглавление)

## 13 Приведите наиболее существенное отличие между CountDownLatch и CyclicBarrier.

[К оглавлению &#8593;](#Оглавление)

## 14 Приведите наиболее существенное отличие между CyclicBarrier и Phaser.

[К оглавлению &#8593;](#Оглавление)

## 15 Расскажите про Exchanger.

[К оглавлению &#8593;](#Оглавление)

## 16 Отличие Thread.start() и Thread.run()?

[К оглавлению &#8593;](#Оглавление)

## 17 Объясните ключевое слово volatile.

[К оглавлению &#8593;](#Оглавление)

## 18 Расскажите про приоритеты потока.

[К оглавлению &#8593;](#Оглавление)

## 19 Что такое потоки-демоны?

[К оглавлению &#8593;](#Оглавление)

## 20 Назовите все возможные состояния потока.

+ NEW - нить создана, но не запущена.
+ RUNNABLE - нить запущена и выполняется.
+ BLOCKED - нить заблокирована.
+ WAITING - нить ожидает уведомления.
+ TIMED_WAITING - нить ожидает уведомление в течении определенного периода.
+ TERMINATED - нить завершила работу.

[К оглавлению &#8593;](#Оглавление)

## 21 Что такое race condition?

[К оглавлению &#8593;](#Оглавление)

## 22 Что такое Thread Local переменная?

[К оглавлению &#8593;](#Оглавление)

## 23 Что такое FutureTask?

[К оглавлению &#8593;](#Оглавление)

## 24 Что такое Thread Pool?

[К оглавлению &#8593;](#Оглавление)

## 25 Что такое Semaphore?

[К оглавлению &#8593;](#Оглавление)

## 26 Чем отличается submit от execute у ExecutorService?

[К оглавлению &#8593;](#Оглавление)

## 27 Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

[К оглавлению &#8593;](#Оглавление)

## 28 Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

[К оглавлению &#8593;](#Оглавление)

## 29 Что такое ReadWriteLock?

[К оглавлению &#8593;](#Оглавление)

## 30 В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

[К оглавлению &#8593;](#Оглавление)

## 31 Расскажите про шаблон проектирования Producer Consumer.

[К оглавлению &#8593;](#Оглавление)

## 32 Как можно запустить параллельный поток (parallelStream)?

[К оглавлению &#8593;](#Оглавление)

## 33 Что делают методы parallel и sequential?

[К оглавлению &#8593;](#Оглавление)

## 34 Расскажите про порядок следования элементов в параллельном потоке и его особенностях.

[К оглавлению &#8593;](#Оглавление)

## 35 В чем разница между методами forEach и forEachOrdered?

[К оглавлению &#8593;](#Оглавление)

## 36 В чем разница между применением метода peek() в последовательном и параллельном потоках?

[К оглавлению &#8593;](#Оглавление)

## 37 Что делает метод unordered?

[К оглавлению &#8593;](#Оглавление)

## 38 Когда имеет смысл распараллеливать поток и какие при этом должны соблюдаться условия?

[К оглавлению &#8593;](#Оглавление)

## 39 Расскажите про Java NIO и её главные составляющие.

[К оглавлению &#8593;](#Оглавление)

## 40 Что такое канал?

[К оглавлению &#8593;](#Оглавление)

## 41 Что такое буфер?

[К оглавлению &#8593;](#Оглавление)

## 42 Что такое селектор?

[К оглавлению &#8593;](#Оглавление)

## 43 Когда есть смысл использовать Java NIO?

[К оглавлению &#8593;](#Оглавление)

## 44 Что такое PipedStreams? Как они устроены?

[К оглавлению &#8593;](#Оглавление)